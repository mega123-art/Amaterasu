// // anchorclient.js

// const fs = require("fs").promises;
// const path = require("path");
// const {
//   Connection,
//   PublicKey,
//   Keypair,
//   LAMPORTS_PER_SOL,
//   SystemProgram,
// } = require("@solana/web3.js");
// const anchor = require("@project-serum/anchor");

// /**
//  * A client for interacting with the Poloc Anchor smart contract.
//  */
// class AnchorClient {
//   /**
//    * @param {Connection} connection
//    * @param {anchor.Wallet} wallet
//    * @param {anchor.Program} program
//    */
//   constructor(connection, wallet, program) {
//     this.connection = connection;
//     this.wallet = wallet;
//     this.program = program;
//   }

//   /**
//    * Creates and initializes a new AnchorClient.
//    * @param {string} [walletPath] - Optional path to the wallet keypair file.
//    * @param {string} [rpcEndpoint] - Optional URL for the Solana RPC endpoint.
//    * @returns {Promise<AnchorClient>} A new instance of the AnchorClient.
//    */
//   static async create(walletPath, rpcEndpoint) {
//     // --- 1. Establish Connection ---
//     const endpoint = rpcEndpoint || "https://api.devnet.solana.com";
//     const connection = new Connection(endpoint, "confirmed");
//     console.log(`âœ… Connected to Solana devnet at ${endpoint}`);

//     // --- 2. Load Wallet ---
//     const keypairPath =
//       walletPath || path.join(process.env.HOME, ".config", "solana", "id.json");
//     const secretKey = JSON.parse(await fs.readFile(keypairPath, "utf8"));
//     const keypair = Keypair.fromSecretKey(new Uint8Array(secretKey));
//     const wallet = new anchor.Wallet(keypair);
//     console.log(`âœ… Wallet loaded: ${wallet.publicKey.toString()}`);

//     // --- 3. Load Program ---
//     const provider = new anchor.AnchorProvider(connection, wallet, {
//       commitment: "confirmed",
//     });
//     // The IDL is the JSON file that describes your program, generated by `anchor build`.
//     const idlPath = path.join(__dirname, "poloc.json"); // Assumes IDL is named 'poloc.json'
//     const idl = JSON.parse(await fs.readFile(idlPath, "utf8"));
//     const programId = new PublicKey(idl.metadata.address);
//     const program = new anchor.Program(idl, programId, provider);
//     console.log(`âœ… Program loaded: ${program.programId.toString()}`);

//     return new AnchorClient(connection, wallet, program);
//   }

//   // --- Public Utility Methods ---

//   /**
//    * Requests a devnet airdrop for the connected wallet.
//    * @param {number} amountSOL - The amount of SOL to request.
//    */
//   async requestAirdrop(amountSOL = 1) {
//     console.log(
//       `ðŸ’° Requesting ${amountSOL} SOL airdrop for ${this.wallet.publicKey.toString()}...`
//     );
//     const signature = await this.connection.requestAirdrop(
//       this.wallet.publicKey,
//       amountSOL * LAMPORTS_PER_SOL
//     );
//     await this.connection.confirmTransaction(signature, "confirmed");
//     console.log(
//       `âœ… Airdrop successful! New balance: ${await this.getWalletBalance()} SOL`
//     );
//   }

//   /**
//    * Gets the current balance of the connected wallet in SOL.
//    * @returns {Promise<number>} The balance in SOL.
//    */
//   async getWalletBalance() {
//     const balance = await this.connection.getBalance(this.wallet.publicKey);
//     return balance / LAMPORTS_PER_SOL;
//   }

//   // --- On-Chain Instruction Methods ---

//   /**
//    * Initializes a new challenge on the blockchain.
//    * @param {object} params
//    * @param {string} params.challengeId - A unique string identifier for the challenge.
//    * @param {{lat: number, lon: number}} params.location - The claimed location.
//    * @param {number} params.duration - The duration of the challenge in seconds.
//    * @param {number} params.rewardPool - The reward pool in lamports.
//    * @returns {Promise<string>} The transaction signature.
//    */
//   async initializeChallenge({ challengeId, location, duration, rewardPool }) {
//     const challengePda = this._findChallengePda(challengeId);

//     const tx = await this.program.methods
//       .initializeChallenge(
//         challengeId,
//         Math.round(location.lat * 1e6), // Convert to micro-degrees
//         Math.round(location.lon * 1e6),
//         new anchor.BN(duration),
//         new anchor.BN(rewardPool)
//       )
//       .accounts({
//         challenge: challengePda,
//         waldo: this.wallet.publicKey,
//         systemProgram: SystemProgram.programId,
//       })
//       .rpc();

//     console.log(
//       `âœ… Challenge '${challengeId}' created successfully. Tx: ${tx}`
//     );
//     return tx;
//   }

//   /**
//    * Stakes lamports for a specific challenge.
//    * @param {string} challengeId - The ID of the challenge to stake in.
//    * @param {number} amount - The amount to stake in lamports.
//    * @returns {Promise<string>} The transaction signature.
//    */
//   async stakeForChallenge(challengeId, amount) {
//     const challengePda = this._findChallengePda(challengeId);
//     const stakePda = this._findStakePda(challengeId, this.wallet.publicKey);

//     const tx = await this.program.methods
//       .stake(challengeId, new anchor.BN(amount))
//       .accounts({
//         challenge: challengePda,
//         stake: stakePda,
//         challenger: this.wallet.publicKey,
//         systemProgram: SystemProgram.programId,
//       })
//       .rpc();

//     console.log(
//       `âœ… Staked ${
//         amount / LAMPORTS_PER_SOL
//       } SOL for challenge '${challengeId}'. Tx: ${tx}`
//     );
//     return tx;
//   }

//   /**
//    * Submits a vote for a challenge.
//    * @param {object} params
//    * @param {string} params.challengeId
//    * @param {boolean} params.isValid - The voter's decision.
//    * @param {number} params.uncertainty - The voter's calculated uncertainty in meters.
//    * @param {number} params.minRtt - The voter's measured minimum RTT in microseconds.
//    * @returns {Promise<string>} The transaction signature.
//    */
//   async submitVote({ challengeId, isValid, uncertainty, minRtt }) {
//     const challengePda = this._findChallengePda(challengeId);
//     const stakePda = this._findStakePda(challengeId, this.wallet.publicKey);
//     const votePda = this._findVotePda(challengeId, this.wallet.publicKey);

//     const tx = await this.program.methods
//       .submitVote(
//         challengeId,
//         this.wallet.publicKey.toString(), // Using wallet pubkey as challenger_id
//         isValid,
//         uncertainty,
//         minRtt
//       )
//       .accounts({
//         challenge: challengePda,
//         stakeAccount: stakePda,
//         voteAccount: votePda,
//         challenger: this.wallet.publicKey,
//         systemProgram: SystemProgram.programId,
//       })
//       .rpc();

//     console.log(`âœ… Vote submitted for challenge '${challengeId}'. Tx: ${tx}`);
//     return tx;
//   }

//   /**
//    * Finalizes a challenge by submitting the off-chain calculated result.
//    * @param {string} challengeId - The ID of the challenge to finalize.
//    * @param {number} rStar - The final R* uncertainty value calculated off-chain.
//    * @returns {Promise<string>} The transaction signature.
//    */
//   async finalizeChallenge(challengeId, rStar) {
//     const challengePda = this._findChallengePda(challengeId);

//     const tx = await this.program.methods
//       .finalizeChallenge(challengeId, rStar)
//       .accounts({
//         challenge: challengePda,
//         authority: this.wallet.publicKey,
//       })
//       .rpc();

//     console.log(`âœ… Challenge '${challengeId}' finalized. Tx: ${tx}`);
//     return tx;
//   }

//   /**
//    * Fetches all active challenge accounts from the blockchain.
//    * @returns {Promise<object[]>} An array of challenge data objects.
//    */
//   async getActiveChallenges() {
//     const allChallenges = await this.program.account.challenge.all();

//     // Filter for only active challenges and map to a clean JS object
//     return allChallenges
//       .filter((c) => Object.keys(c.account.status)[0] === "active")
//       .map((c) => ({
//         id: c.account.challengeId,
//         publicKey: c.publicKey.toString(),
//         waldo: c.account.waldo.toString(),
//         claimedLocation: {
//           lat: c.account.claimedLat / 1e6,
//           lon: c.account.claimedLon / 1e6,
//         },
//         rewardPool: c.account.rewardPool.toNumber(),
//         deadline: new Date(c.account.deadline.toNumber() * 1000),
//         participantCount: c.account.participantCount,
//         voteCount: c.account.voteCount,
//       }));
//   }

//   // --- Private Helper Methods for Finding PDAs ---

//   _findChallengePda(challengeId) {
//     const [pda] = PublicKey.findProgramAddressSync(
//       [Buffer.from("challenge"), Buffer.from(challengeId)],
//       this.program.programId
//     );
//     return pda;
//   }

//   _findStakePda(challengeId, userPublicKey) {
//     const [pda] = PublicKey.findProgramAddressSync(
//       [
//         Buffer.from("stake"),
//         this._findChallengePda(challengeId).toBuffer(),
//         userPublicKey.toBuffer(),
//       ],
//       this.program.programId
//     );
//     return pda;
//   }

//   _findVotePda(challengeId, userPublicKey) {
//     const [pda] = PublicKey.findProgramAddressSync(
//       [
//         Buffer.from("vote"),
//         this._findChallengePda(challengeId).toBuffer(),
//         userPublicKey.toBuffer(),
//       ],
//       this.program.programId
//     );
//     return pda;
//   }
// }

// module.exports = { AnchorClient };
// anchorclient.js

const fs = require("fs").promises;
const path = require("path");
const {
  Connection,
  PublicKey,
  Keypair,
  LAMPORTS_PER_SOL,
  SystemProgram,
} = require("@solana/web3.js");
const anchor = require("@coral-xyz/anchor");
const BN = require("bn.js");
const nacl = require("tweetnacl");
const bs58 = require("bs58");

/**
 * A client for interacting with the Poloc Anchor smart contract.
 */
class AnchorClient {
  /**
   * @param {Connection} connection
   * @param {anchor.Wallet} wallet
   * @param {anchor.Program} program
   */
  constructor(connection, wallet, program) {
    this.connection = connection;
    this.wallet = wallet;
    this.program = program;
  }

  /**
   * Creates and initializes a new AnchorClient.
   * @param {string} [walletPath] - Optional path to the wallet keypair file.
   * @param {string} [rpcEndpoint] - Optional URL for the Solana RPC endpoint.
   * @returns {Promise<AnchorClient>} A new instance of the AnchorClient.
   */
  static async create(walletPath, rpcEndpoint) {
    // --- 1. Establish Connection ---
    // FIX: Default to local network for testing, allow override for devnet/mainnet.
    const endpoint = rpcEndpoint || "http://127.0.0.1:8899";
    const connection = new Connection(endpoint, "confirmed");
    const networkType = endpoint.includes("devnet") ? "devnet" : "localnet";
    console.log(`âœ… Connected to Solana ${networkType} at ${endpoint}`);


    // --- 2. Load Wallet ---
    const keypairPath =
      walletPath || path.join(process.env.HOME, ".config", "solana", "id.json");
    const secretKey = JSON.parse(await fs.readFile(keypairPath, "utf8"));
    const keypair = Keypair.fromSecretKey(new Uint8Array(secretKey));
    const wallet = new anchor.Wallet(keypair);
    console.log(`âœ… Wallet loaded: ${wallet.publicKey.toString()}`);

    // --- 3. Load Program ---
    const provider = new anchor.AnchorProvider(connection, wallet, {
      commitment: "confirmed",
    });
    // Try using the old IDL file that was working before
    const idlPath = path.join(__dirname, "polocfinal.json");
    const idl = JSON.parse(await fs.readFile(idlPath, "utf8"));
    const programId = new PublicKey(idl.address);
    
    // Try to create program with the IDL
    const program = new anchor.Program(idl, programId, provider);
    console.log(`âœ… Program loaded: ${program.programId.toString()}`);

    return new AnchorClient(connection, wallet, program);
  }

  // --- Public Utility Methods ---

  /**
   * Requests a devnet airdrop for the connected wallet.
   * @param {number} amountSOL - The amount of SOL to request.
   */
  async requestAirdrop(amountSOL = 1) {
    console.log(
      `ðŸ’° Requesting ${amountSOL} SOL airdrop for ${this.wallet.publicKey.toString()}...`
    );
    const signature = await this.connection.requestAirdrop(
      this.wallet.publicKey,
      amountSOL * LAMPORTS_PER_SOL
    );
    await this.connection.confirmTransaction(signature, "confirmed");
    console.log(
      `âœ… Airdrop successful! New balance: ${await this.getWalletBalance()} SOL`
    );
  }

  /**
   * Signs a message with the wallet's keypair.
   * @param {string} message - The message to sign.
   * @returns {string} The signature as a base58 string.
   */
  signMessage(message) {
    const messageBuffer = Buffer.from(message, 'utf8');
    const signature = nacl.sign.detached(messageBuffer, this.wallet.payer.secretKey);
    return bs58.encode(signature);
  }

  /**
   * Gets the current balance of the connected wallet in SOL.
   * @returns {Promise<number>} The balance in SOL.
   */
  async getWalletBalance() {
    const balance = await this.connection.getBalance(this.wallet.publicKey);
    return balance / LAMPORTS_PER_SOL;
  }

  // --- On-Chain Instruction Methods ---

  /**
   * Initializes a new challenge on the blockchain.
   * @param {object} params
   * @param {string} params.challengeId - A unique string identifier for the challenge.
   * @param {{lat: number, lon: number}} params.location - The claimed location.
   * @param {number} params.duration - The duration of the challenge in seconds.
   * @param {number} params.rewardPool - The reward pool in lamports.
   * @returns {Promise<string>} The transaction signature.
   */
  async initializeChallenge({ challengeId, location, duration, rewardPool }) {
    const challengePda = this._findChallengePda(challengeId);

    const tx = await this.program.methods
      .initialize_challenge(
        challengeId,
        Math.round(location.lat * 1e6), // Convert to micro-degrees
        Math.round(location.lon * 1e6),
        new BN(duration),
        new BN(rewardPool)
      )
      .accounts({
        challenge: challengePda,
        waldo: this.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([this.wallet.payer]) // Use the keypair from the wallet
      .rpc();

    console.log(
      `âœ… Challenge '${challengeId}' created successfully. Tx: ${tx}`
    );
    return tx;
  }

  /**
   * Stakes lamports for a specific challenge.
   * @param {string} challengeId - The ID of the challenge to stake in.
   * @param {number} amount - The amount to stake in lamports.
   * @returns {Promise<string>} The transaction signature.
   */
  async stakeForChallenge(challengeId, amount) {
    const challengePda = this._findChallengePda(challengeId);
    const stakePda = this._findStakePda(challengeId, this.wallet.publicKey);

    const tx = await this.program.methods
      .stake(challengeId, new BN(amount))
      .accounts({
        challenge: challengePda,
        stakeAccount: stakePda, // Updated to match your IDL
        challenger: this.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([this.wallet.payer])
      .rpc();

    console.log(
      `âœ… Staked ${
        amount / LAMPORTS_PER_SOL
      } SOL for challenge '${challengeId}'. Tx: ${tx}`
    );
    return tx;
  }

  /**
   * Submits a vote for a challenge.
   * @param {object} params
   * @param {string} params.challengeId
   * @param {boolean} params.isValid - The voter's decision.
   * @param {number} params.uncertainty - The voter's calculated uncertainty in meters.
   * @param {number} params.minRtt - The voter's measured minimum RTT in microseconds.
   * @returns {Promise<string>} The transaction signature.
   */
  async submitVote({ challengeId, isValid, uncertainty, minRtt }) {
    const challengePda = this._findChallengePda(challengeId);
    const stakePda = this._findStakePda(challengeId, this.wallet.publicKey);
    const votePda = this._findVotePda(challengeId, this.wallet.publicKey);

    const tx = await this.program.methods
      .submit_vote(
        challengeId,
        this.wallet.publicKey.toString(), // Using wallet pubkey as challenger_id
        isValid,
        uncertainty,
        minRtt
      )
      .accounts({
        challenge: challengePda,
        stakeAccount: stakePda,
        voteAccount: votePda,
        challenger: this.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([this.wallet.payer])
      .rpc();

    console.log(`âœ… Vote submitted for challenge '${challengeId}'. Tx: ${tx}`);
    return tx;
  }

  /**
   * Finalizes a challenge by submitting the off-chain calculated result.
   * @param {string} challengeId - The ID of the challenge to finalize.
   * @param {number} rStar - The final R* uncertainty value calculated off-chain.
   * @returns {Promise<string>} The transaction signature.
   */
  async finalizeChallenge(challengeId, rStar) {
    const challengePda = this._findChallengePda(challengeId);

    const tx = await this.program.methods
      .finalize_challenge(challengeId, rStar)
      .accounts({
        challenge: challengePda,
        authority: this.wallet.publicKey,
      })
      .signers([this.wallet.payer])
      .rpc();

    console.log(`âœ… Challenge '${challengeId}' finalized. Tx: ${tx}`);
    return tx;
  }

  /**
   * Gets the status of a specific challenge.
   * @param {string} challengeId - The ID of the challenge to check.
   * @returns {Promise<object>} The challenge status data.
   */
  async getChallengeStatus(challengeId) {
    const challengePda = this._findChallengePda(challengeId);
    const challengeAccount = await this.program.account.challenge.fetch(challengePda);
    
    return {
      participantCount: challengeAccount.participantCount,
      voteCount: challengeAccount.voteCount,
      validVoteCount: challengeAccount.validVoteCount,
      status: challengeAccount.status,
      deadline: challengeAccount.deadline.toNumber(),
      rStar: challengeAccount.rStar,
      rStarThreshold: challengeAccount.rStarThreshold,
    };
  }

  /**
   * Distributes rewards to honest participants.
   * @param {string} challengeId - The ID of the challenge.
   * @returns {Promise<string>} The transaction signature.
   */
  async distributeRewards(challengeId) {
    const challengePda = this._findChallengePda(challengeId);
    
    const tx = await this.program.methods
      .claim_reward(challengeId)
      .accounts({
        challenge: challengePda,
        vote: this._findVotePda(challengeId, this.wallet.publicKey),
        winner: this.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([this.wallet.payer])
      .rpc();

    console.log(`âœ… Rewards distributed for challenge '${challengeId}'. Tx: ${tx}`);
    return tx;
  }

  /**
   * Fetches all active challenge accounts from the blockchain.
   * @returns {Promise<object[]>} An array of challenge data objects.
   */
  async getActiveChallenges() {
    const allChallenges = await this.program.account.challenge.all();

    // Filter for only active challenges and map to a clean JS object
    return allChallenges
      .filter((c) => Object.keys(c.account.status)[0] === "active")
      .map((c) => ({
        id: c.account.challengeId,
        publicKey: c.publicKey.toString(),
        waldo: c.account.waldo.toString(),
        claimedLocation: {
          lat: c.account.claimedLat / 1e6,
          lon: c.account.claimedLon / 1e6,
        },
        rewardPool: c.account.rewardPool.toNumber(),
        deadline: new Date(c.account.deadline.toNumber() * 1000),
        participantCount: c.account.participantCount,
        voteCount: c.account.voteCount,
      }));
  }

  // --- Private Helper Methods for Finding PDAs ---

  _findChallengePda(challengeId) {
    const [pda] = PublicKey.findProgramAddressSync(
      [Buffer.from("challenge"), Buffer.from(challengeId)],
      this.program.programId
    );
    return pda;
  }

  _findStakePda(challengeId, userPublicKey) {
    const challengePda = this._findChallengePda(challengeId);
    const [pda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("stake"),
        challengePda.toBuffer(),
        userPublicKey.toBuffer(),
      ],
      this.program.programId
    );
    return pda;
  }

  _findVotePda(challengeId, userPublicKey) {
    const challengePda = this._findChallengePda(challengeId);
    const [pda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("vote"),
        challengePda.toBuffer(),
        userPublicKey.toBuffer(),
      ],
      this.program.programId
    );
    return pda;
  }
}

module.exports = { AnchorClient };
